window.signatureConditions = (function() {
  // this file contains generated code for region 'Global'. Do not modify, your changes will be overwritten!!!
  /* tslint:disable:comma-dangle no-string-literal no-unused-variable whitespace no-unused-vars no-trailing-whitespace no-unreachable max-line-length curly comment-format no-trailing-comma */
  var _log;
  var log = function() {
    if (!_log) {
      _log = logger.getLoggerFor('editabilityPolicy');
    }
    _log(arguments);
  };
  var signaturesPerKind = {
    Isolation: {
      // kind: Isolation
      AmendmentOfIsolationPlan: {
        key: 'AmendmentOfIsolationPlan', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictParentState/>
          if (function() {
            if (!(cert.hasParents(['Permit'], []))) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictParentState(cert, violations, {
              kind: 'Permit',
              prohibitedStates: ['Issued', 'Revalidate', 'AwaitingActivation', 'Active', 'ActiveForSanctionToTest', 'ReIssued', 'ReIssuedForSanctionToTest'],
              allowedStates: []
            });
          }
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'WorkPack',
            prohibitedStates: ['Active'],
            allowedStates: []
          });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['IsolationInPlace'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInPlace'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      AuditLti: {
        key: 'AuditLti', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule scheduleAuditLtiExpiration not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInPlaceForLongTerm'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      CancelDeisolationForTestRequest: {
        key: 'CancelDeisolationForTestRequest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"CancelRequestedDeisolations","uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['RequestedForSanctionToTest'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      CancelDeisolationRequest: {
        key: 'CancelDeisolationRequest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"CancelRequestedDeisolations","uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['DeisolationInProgress'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['DeisolationInProgress'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      CancelIsolationRequest: {
        key: 'CancelIsolationRequest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"CancelRequestedIsolations","uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['IsolationInProgress'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInProgress'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      CancelReisolationRequest: {
        key: 'CancelReisolationRequest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"CancelRequestedIsolations","uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['RequestedForReisolation'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForReisolation'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      CloseIsolationCertificate: {
        key: 'CloseIsolationCertificate', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'Permit',
            prohibitedStates: [],
            allowedStates: ['Closing', 'Closed']
          });
          // Rule <signAttachedCertificate> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.instructionPlanInfo && cert.instructionPlanInfo.allDeisolationInstructionsPerformed)) {
            return false;
          }
          if (!(_.includes(['Deisolated', 'IsolationInPlaceForSanctionToTest'], cert.state))) {
            return false;
          }
          if (!(/* <anyOf> condition: a single condition below must match */
          function() {
            if (!(cert.hasParents(['Permit'], []))) {
              return true;
            }
            if ((cert.hasParents(['Permit'], ['Closing', 'Closed']))) {
              return true;
            }
            return false; /* Not any condition is true, so return false */
          }())) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Deisolated', 'IsolationInPlaceForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmAllIsolationsInPlace: {
        key: 'ConfirmAllIsolationsInPlace', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"selfDeclaration","errorResource":"SelfDeclarationConfirmAllIsolationsInPlaceErrorMessage","textResource":"SelfDeclarationConfirmAllIsolationsInPlace","uniqueKey":"selfDeclaration_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictRiskAssessmentAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'TaskRiskAssessment',
            isRequired: false,
            variants: [],
            inStates: ['Active'],
            notInStates: []
          });
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['Mechanical']))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'Mechanical');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalLowVoltage']))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'ElectricalLowVoltage');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalHighVoltage']))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'ElectricalHighVoltage');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['InhibitsAndOverrides']))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'InhibitsAndOverrides');
          }
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <requireLevel2RiskAssessmentForNonStandardSchemes/>
          if (function() {
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireLevel2RiskAssessmentForNonStandardSchemes(cert, violations, ['Mechanical', 'ElectricalLowVoltage', 'ElectricalHighVoltage', 'InhibitsAndOverrides']);
          }
          // Rule <restrictWorkItemAttachment/>
          if (function() {
            if (!(_.some(cert.attachments, function(att) { return att.kind === 'TaskRiskAssessment' && (function(cert) {
              return true;
            })(att) }))) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictWorkItemAttachment(cert, violations, {
              kind: 'TaskRiskAssessment',
              isRequired: false,
              variants: [],
              inStates: ['Active'],
              notInStates: [],
              anyInStates: []
            });
          }
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.instructionPlanInfo && cert.instructionPlanInfo.allIsolationInstructionsPerformed)) {
            return false;
          }
          if (!(_.includes(['IsolationInProgress', 'AwaitingAuthorisation', 'IsolationInProgressForAmendment', 'AwaitingAuthorisationForAmendment', 'RequestedForAmendment'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInProgress', 'AwaitingAuthorisation', 'IsolationInProgressForAmendment', 'AwaitingAuthorisationForAmendment', 'RequestedForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmDeisolationActionPerformed: {
        key: 'ConfirmDeisolationActionPerformed', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmDeisolation","enableBarcodeScanning":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['DeisolationInProgress'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['DefaultIsolationCertificate'], cert.variant) && _.includes(['DeisolationInProgress'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmDeisolationForSTTActionPerformed: {
        key: 'ConfirmDeisolationForSTTActionPerformed', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmDeisolationForSanctionToTest","useLockoutBox":true,"utiUsage":"None","enableBarcodeScanning":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['RequestedForSanctionToTest'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmDeisolationsInPlaceForSanctionToTest: {
        key: 'ConfirmDeisolationsInPlaceForSanctionToTest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['RequestedForSanctionToTest'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmElectricalHighVoltageDeisolations: {
        key: 'ConfirmElectricalHighVoltageDeisolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmDeisolation","enableBarcodeScanning":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, ['ElectricalHighVoltage']))) {
            return false;
          }
          if (!(_.includes(['DeisolationInProgress'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['DeisolationInProgress'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmElectricalHighVoltageDeisolationsForSanctionToTest: {
        key: 'ConfirmElectricalHighVoltageDeisolationsForSanctionToTest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmDeisolationForSanctionToTest","useLockoutBox":true,"utiUsage":"None","enableBarcodeScanning":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, ['ElectricalHighVoltage']))) {
            return false;
          }
          if (!(_.includes(['RequestedForSanctionToTest'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmElectricalHighVoltageIsolations: {
        key: 'ConfirmElectricalHighVoltageIsolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmIsolation","enableBarcodeScanning":true,"showLockNumber":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, ['ElectricalHighVoltage']))) {
            return false;
          }
          if (!(_.includes(['IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmElectricalHighVoltageReisolations: {
        key: 'ConfirmElectricalHighVoltageReisolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmReisolation","enableBarcodeScanning":true,"showLockNumber":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, ['ElectricalHighVoltage']))) {
            return false;
          }
          if (!(_.includes(['RequestedForReisolation'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForReisolation'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmElectricalLowVoltageDeisolations: {
        key: 'ConfirmElectricalLowVoltageDeisolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmDeisolation","enableBarcodeScanning":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, ['ElectricalLowVoltage']))) {
            return false;
          }
          if (!(_.includes(['DeisolationInProgress'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['DeisolationInProgress'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmElectricalLowVoltageDeisolationsForSanctionToTest: {
        key: 'ConfirmElectricalLowVoltageDeisolationsForSanctionToTest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmDeisolationForSanctionToTest","useLockoutBox":true,"utiUsage":"None","enableBarcodeScanning":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, ['ElectricalLowVoltage']))) {
            return false;
          }
          if (!(_.includes(['RequestedForSanctionToTest'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmElectricalLowVoltageIsolations: {
        key: 'ConfirmElectricalLowVoltageIsolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmIsolation","enableBarcodeScanning":true,"showLockNumber":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, ['ElectricalLowVoltage']))) {
            return false;
          }
          if (!(_.includes(['IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmElectricalLowVoltageReisolations: {
        key: 'ConfirmElectricalLowVoltageReisolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmReisolation","enableBarcodeScanning":true,"showLockNumber":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, ['ElectricalLowVoltage']))) {
            return false;
          }
          if (!(_.includes(['RequestedForReisolation'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForReisolation'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmInhibitsAndOverridesDeisolations: {
        key: 'ConfirmInhibitsAndOverridesDeisolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmDeisolation","enableBarcodeScanning":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, ['InhibitsAndOverrides']))) {
            return false;
          }
          if (!(_.includes(['DeisolationInProgress'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['DeisolationInProgress'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmInhibitsAndOverridesDeisolationsForSanctionToTest: {
        key: 'ConfirmInhibitsAndOverridesDeisolationsForSanctionToTest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmDeisolationForSanctionToTest","useLockoutBox":true,"utiUsage":"None","enableBarcodeScanning":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, ['InhibitsAndOverrides']))) {
            return false;
          }
          if (!(_.includes(['RequestedForSanctionToTest'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmInhibitsAndOverridesIsolations: {
        key: 'ConfirmInhibitsAndOverridesIsolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmIsolation","enableBarcodeScanning":true,"showLockNumber":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, ['InhibitsAndOverrides']))) {
            return false;
          }
          if (!(_.includes(['IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmInhibitsAndOverridesReisolations: {
        key: 'ConfirmInhibitsAndOverridesReisolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmReisolation","enableBarcodeScanning":true,"showLockNumber":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, ['InhibitsAndOverrides']))) {
            return false;
          }
          if (!(_.includes(['RequestedForReisolation'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForReisolation'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmIsolationActionPerformed: {
        key: 'ConfirmIsolationActionPerformed', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmIsolation","enableBarcodeScanning":true,"showLockNumber":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['RequestedForAmendment', 'IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['DefaultIsolationCertificate'], cert.variant) && _.includes(['RequestedForAmendment', 'IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmMechanicalDeisolations: {
        key: 'ConfirmMechanicalDeisolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmDeisolation","enableBarcodeScanning":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, ['Mechanical']))) {
            return false;
          }
          if (!(_.includes(['DeisolationInProgress'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['DeisolationInProgress'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmMechanicalDeisolationsForSanctionToTest: {
        key: 'ConfirmMechanicalDeisolationsForSanctionToTest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmDeisolationForSanctionToTest","useLockoutBox":true,"utiUsage":"None","enableBarcodeScanning":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedDeisolations(cert.instructionPlanInfo, ['Mechanical']))) {
            return false;
          }
          if (!(_.includes(['RequestedForSanctionToTest'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmMechanicalIsolations: {
        key: 'ConfirmMechanicalIsolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmIsolation","enableBarcodeScanning":true,"showLockNumber":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, ['Mechanical']))) {
            return false;
          }
          if (!(_.includes(['IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmMechanicalReisolations: {
        key: 'ConfirmMechanicalReisolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmReisolation","enableBarcodeScanning":true,"showLockNumber":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, ['Mechanical']))) {
            return false;
          }
          if (!(_.includes(['RequestedForReisolation'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForReisolation'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmReisolationActionPerformed: {
        key: 'ConfirmReisolationActionPerformed', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"ConfirmReisolation","enableBarcodeScanning":true,"showLockNumber":true,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['RequestedForReisolation'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForReisolation'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ConfirmReisolationsInPlace: {
        key: 'ConfirmReisolationsInPlace', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((certificateMethods.hasRequestedIsolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['RequestedForReisolation'], cert.state))) {
            return false;
          }
          if (!(cert.instructionPlanInfo && cert.instructionPlanInfo.allIsolationInstructionsPerformed)) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForReisolation'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      Counter: {
        key: 'Counter', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: Isolation
      MarkAsNotCopyable: {
        key: 'MarkAsNotCopyable', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <markAsNotCopyable> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((cert.signedWith(['MarkAsNotCopyable'], []))) {
            return false;
          }
          if ((_.includes(['Requesting', 'DraftShutdown'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInProgress', 'IsolationInPlace', 'IsolationInProgressForAmendment', 'IsolationInPlaceForLongTerm', 'RequestedForSanctionToTest', 'IsolationInPlaceForSanctionToTest', 'DeisolationInProgress', 'RequestedForReisolation', 'Deisolated', 'Closed', 'AwaitingVerification', 'AwaitingAuthorisation', 'AwaitingVerificationForAmendment', 'AwaitingAuthorisationForAmendment', 'RequestedForSanctionToTest', 'RequestedForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      MoveFromLongTerm: {
        key: 'MoveFromLongTerm', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule cancelAuditLtiExpiration not yet implemented
          // rule cancelReviewLtiExpiration not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInPlaceForLongTerm'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      MoveToLongTerm: {
        key: 'MoveToLongTerm', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Required',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'Permit',
            prohibitedStates: [],
            allowedStates: ['Closing', 'Closed']
          });
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'WorkPack',
            prohibitedStates: ['Active'],
            allowedStates: []
          });
          // Rule <transition> is explicitly excluded from client side code generation
          // rule scheduleReviewLtiExpiration not yet implemented
          // rule scheduleAuditLtiExpiration not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInPlace'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      PbuMeasurement: {
        key: 'PbuMeasurement', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: Isolation
      ProposeElectricalHighVoltageIsolationScheme: {
        key: 'ProposeElectricalHighVoltageIsolationScheme', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <requireSchemeAssessment/>
          validationRules.requireSchemeAssessment(cert, violations, 'ElectricalHighVoltage');
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['Mechanical']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'Mechanical');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalLowVoltage']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'ElectricalLowVoltage');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['InhibitsAndOverrides']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'InhibitsAndOverrides');
          }
          // Rule <requireLevel2RiskAssessmentForNonStandardSchemes/>
          validationRules.requireLevel2RiskAssessmentForNonStandardSchemes(cert, violations, ['ElectricalHighVoltage']);
          // Rule <requireIsolation/>
          if (function() {
            if (!(/* <anyOf> condition: a single condition below must match */
            function() {
              if ((/* <all> condition: all conditions below must match */
              function() {
                // unsupportedCondition hasIsolationsThatAreUnableToIsolate
                if (!(_.includes(['Requesting'], cert.state))) {
                  return false;
                }
                return true; /* No condition was false, so return true */
              }())) {
                return true;
              }
              if ((/* <all> condition: all conditions below must match */
              function() {
                // unsupportedCondition hasIsolationsThatAreUnableToIsolate
                if (!(_.includes(['RequestedForAmendment'], cert.state))) {
                  return false;
                }
                return true; /* No condition was false, so return true */
              }())) {
                return true;
              }
              return false; /* Not any condition is true, so return false */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireIsolation(cert, violations, 'ElectricalHighVoltage')
          }
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'TaskRiskAssessment',
            isRequired: false,
            variants: [],
            inStates: ['Active'],
            notInStates: [],
            anyInStates: []
          });
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // rule assessIsolationScheme not yet implemented
          // rule assessIsolationScheme not yet implemented
          // rule requireIsolationMethodsToBeAvailable not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalHighVoltage']))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting', 'RequestedForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ProposeElectricalLowVoltageIsolationScheme: {
        key: 'ProposeElectricalLowVoltageIsolationScheme', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <requireSchemeAssessment/>
          validationRules.requireSchemeAssessment(cert, violations, 'ElectricalLowVoltage');
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['Mechanical']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'Mechanical');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['InhibitsAndOverrides']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'InhibitsAndOverrides');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalHighVoltage']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'ElectricalHighVoltage');
          }
          // Rule <requireLevel2RiskAssessmentForNonStandardSchemes/>
          validationRules.requireLevel2RiskAssessmentForNonStandardSchemes(cert, violations, ['ElectricalLowVoltage']);
          // Rule <requireIsolation/>
          if (function() {
            if (!(/* <anyOf> condition: a single condition below must match */
            function() {
              if ((/* <all> condition: all conditions below must match */
              function() {
                // unsupportedCondition hasIsolationsThatAreUnableToIsolate
                if (!(_.includes(['Requesting'], cert.state))) {
                  return false;
                }
                return true; /* No condition was false, so return true */
              }())) {
                return true;
              }
              if ((/* <all> condition: all conditions below must match */
              function() {
                // unsupportedCondition hasIsolationsThatAreUnableToIsolate
                if (!(_.includes(['RequestedForAmendment'], cert.state))) {
                  return false;
                }
                return true; /* No condition was false, so return true */
              }())) {
                return true;
              }
              return false; /* Not any condition is true, so return false */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireIsolation(cert, violations, 'ElectricalLowVoltage')
          }
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'TaskRiskAssessment',
            isRequired: false,
            variants: [],
            inStates: ['Active'],
            notInStates: [],
            anyInStates: []
          });
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // rule assessIsolationScheme not yet implemented
          // rule assessIsolationScheme not yet implemented
          // rule requireIsolationMethodsToBeAvailable not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalLowVoltage']))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting', 'RequestedForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ProposeInhibitsAndOverridesIsolationScheme: {
        key: 'ProposeInhibitsAndOverridesIsolationScheme', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <requireSchemeAssessment/>
          validationRules.requireSchemeAssessment(cert, violations, 'InhibitsAndOverrides');
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['Mechanical']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'Mechanical');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalLowVoltage']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'ElectricalLowVoltage');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalHighVoltage']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'ElectricalHighVoltage');
          }
          // Rule <requireIsolation/>
          if (function() {
            if (!(/* <anyOf> condition: a single condition below must match */
            function() {
              if ((/* <all> condition: all conditions below must match */
              function() {
                // unsupportedCondition hasIsolationsThatAreUnableToIsolate
                if (!(_.includes(['Requesting'], cert.state))) {
                  return false;
                }
                return true; /* No condition was false, so return true */
              }())) {
                return true;
              }
              if ((/* <all> condition: all conditions below must match */
              function() {
                // unsupportedCondition hasIsolationsThatAreUnableToIsolate
                if (!(_.includes(['RequestedForAmendment'], cert.state))) {
                  return false;
                }
                return true; /* No condition was false, so return true */
              }())) {
                return true;
              }
              return false; /* Not any condition is true, so return false */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireIsolation(cert, violations, 'InhibitsAndOverrides')
          }
          // Rule <requireLevel2RiskAssessmentForNonStandardSchemes/>
          validationRules.requireLevel2RiskAssessmentForNonStandardSchemes(cert, violations, ['InhibitsAndOverrides']);
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'TaskRiskAssessment',
            isRequired: false,
            variants: [],
            inStates: ['Active'],
            notInStates: [],
            anyInStates: []
          });
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // rule assessIsolationScheme not yet implemented
          // rule assessIsolationScheme not yet implemented
          // rule requireIsolationMethodsToBeAvailable not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasIsolationTypes(cert, ['InhibitsAndOverrides']))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting', 'RequestedForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ProposeMechanicalIsolationScheme: {
        key: 'ProposeMechanicalIsolationScheme', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <requireIsolation/>
          if (function() {
            if (!(/* <anyOf> condition: a single condition below must match */
            function() {
              if ((/* <all> condition: all conditions below must match */
              function() {
                // unsupportedCondition hasIsolationsThatAreUnableToIsolate
                if (!(_.includes(['Requesting'], cert.state))) {
                  return false;
                }
                return true; /* No condition was false, so return true */
              }())) {
                return true;
              }
              if ((/* <all> condition: all conditions below must match */
              function() {
                // unsupportedCondition hasIsolationsThatAreUnableToIsolate
                if (!(_.includes(['RequestedForAmendment'], cert.state))) {
                  return false;
                }
                return true; /* No condition was false, so return true */
              }())) {
                return true;
              }
              return false; /* Not any condition is true, so return false */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireIsolation(cert, violations, 'Mechanical')
          }
          // Rule <requireSchemeAssessment/>
          validationRules.requireSchemeAssessment(cert, violations, 'Mechanical');
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalHighVoltage']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'ElectricalHighVoltage');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalLowVoltage']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'ElectricalLowVoltage');
          }
          // Rule <requireSchemeAssessment/>
          if (function() {
            if (!(certificateMethods.hasIsolationTypes(cert, ['InhibitsAndOverrides']))) {
              return false;
            }
            if (!(_.includes(['RequestedForAmendment'], cert.state))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSchemeAssessment(cert, violations, 'InhibitsAndOverrides');
          }
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <requireLevel2RiskAssessmentForNonStandardSchemes/>
          validationRules.requireLevel2RiskAssessmentForNonStandardSchemes(cert, violations, ['Mechanical']);
          // rule assessIsolationScheme not yet implemented
          // rule assessIsolationScheme not yet implemented
          // rule requireIsolationMethodsToBeAvailable not yet implemented
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'TaskRiskAssessment',
            isRequired: false,
            variants: [],
            inStates: ['Active'],
            notInStates: [],
            anyInStates: []
          });
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasIsolationTypes(cert, ['Mechanical']))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting', 'RequestedForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      RequestDeisolations: {
        key: 'RequestDeisolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"RequestDeisolation","uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'Permit',
            prohibitedStates: [],
            allowedStates: ['Closing', 'Closed']
          });
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'WorkPack',
            prohibitedStates: ['Requesting', 'AwaitingActivation', 'Active', 'RequestedForAmendment', 'AwaitingActivationForAmendment'],
            allowedStates: []
          });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.instructionPlanInfo && certificateMethods.hasUnrequestedDeisolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          if (!(_.includes(['IsolationInPlace', 'DeisolationInProgress', 'IsolationInPlaceForSanctionToTest', 'IsolationInPlaceForLongTerm'], cert.state))) {
            return false;
          }
          if (!(/* <anyOf> condition: a single condition below must match */
          function() {
            if (!(cert.hasParents(['Permit'], []))) {
              return true;
            }
            if ((cert.hasParents(['Permit'], ['Closing', 'Closed']))) {
              return true;
            }
            return false; /* Not any condition is true, so return false */
          }())) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInPlace', 'DeisolationInProgress', 'IsolationInPlaceForSanctionToTest', 'IsolationInPlaceForLongTerm'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      RequestDeisolationsForSanctionToTest: {
        key: 'RequestDeisolationsForSanctionToTest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"RequestDeisolationForSanctionToTest","showLockNumber":false,"uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'WorkPack',
            prohibitedStates: ['Active'],
            allowedStates: []
          });
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'Permit',
            prohibitedStates: ['Issued', 'Active', 'ActiveForSanctionToTest', 'AwaitingActivation', 'ReIssuedForSanctionToTest', 'ReIssued', 'Revalidate', 'Expired'],
            allowedStates: []
          });
          // Rule <requireParent/>
          validationRules.requireParent(cert, violations, {
            kind: 'Permit',
            state: 'SuspendedForSanctionToTest'
          });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(/* <anyOf> condition: a single condition below must match */
          function() {
            if ((cert.instructionPlanInfo && certificateMethods.hasUnrequestedDeisolations(cert.instructionPlanInfo, ['ElectricalLowVoltage']))) {
              return true;
            }
            if ((cert.instructionPlanInfo && certificateMethods.hasUnrequestedDeisolations(cert.instructionPlanInfo, ['ElectricalHighVoltage']))) {
              return true;
            }
            if ((cert.instructionPlanInfo && certificateMethods.hasUnrequestedDeisolations(cert.instructionPlanInfo, ['InhibitsAndOverrides']))) {
              return true;
            }
            if ((cert.instructionPlanInfo && certificateMethods.hasUnrequestedDeisolations(cert.instructionPlanInfo, ['Mechanical']))) {
              return true;
            }
            return false; /* Not any condition is true, so return false */
          }())) {
            return false;
          }
          if (!(_.includes(['IsolationInPlace', 'RequestedForSanctionToTest', 'IsolationInPlaceForSanctionToTest'], cert.state))) {
            return false;
          }
          if (!(cert.hasParents(['Permit'], ['SuspendedForSanctionToTest']))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInPlace', 'RequestedForSanctionToTest', 'IsolationInPlaceForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      RequestIsolations: {
        key: 'RequestIsolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"RequestIsolation","uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireLevel2RiskAssessmentForNonStandardSchemes/>
          validationRules.requireLevel2RiskAssessmentForNonStandardSchemes(cert, violations, ['Mechanical', 'ElectricalLowVoltage', 'ElectricalHighVoltage', 'InhibitsAndOverrides']);
          // Rule <restrictWorkItemAttachment/>
          if (function() {
            if (!(_.some(cert.attachments, function(att) { return att.kind === 'TaskRiskAssessment' && (function(cert) {
              return true;
            })(att) }))) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictWorkItemAttachment(cert, violations, {
              kind: 'TaskRiskAssessment',
              isRequired: false,
              variants: [],
              inStates: ['Active'],
              notInStates: [],
              anyInStates: []
            });
          }
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['IsolationInProgress', 'AwaitingAuthorisation', 'AwaitingAuthorisationForAmendment', 'IsolationInProgressForAmendment'], cert.state))) {
            return false;
          }
          if (!(cert.instructionPlanInfo && certificateMethods.hasUnrequestedIsolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInProgress', 'AwaitingAuthorisation', 'AwaitingAuthorisationForAmendment', 'IsolationInProgressForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      RequestReisolations: {
        key: 'RequestReisolations', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"isolationInstructionsSelector","signingMode":"RequestReisolation","uniqueKey":"isolationInstructionsSelector_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'Permit',
            prohibitedStates: ['Issued', 'Active', 'ActiveForSanctionToTest', 'AwaitingActivation', 'ReIssued', 'ReIssuedForSanctionToTest', 'Revalidate', 'Expired'],
            allowedStates: []
          });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.hasParents([], ['SuspendedForRevalidation', 'SuspendedForEmergency', 'Closing', 'Closed']))) {
            return false;
          }
          if (!(_.includes(['IsolationInPlaceForSanctionToTest', 'RequestedForReisolation'], cert.state))) {
            return false;
          }
          if (!(cert.instructionPlanInfo && certificateMethods.hasUnrequestedIsolations(cert.instructionPlanInfo, []))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInPlaceForSanctionToTest', 'RequestedForReisolation'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      ReviewLti: {
        key: 'ReviewLti', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule scheduleReviewLtiExpiration not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInPlaceForLongTerm'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      UnableToIsolate: {
        key: 'UnableToIsolate', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <violateWithMessage/>
          if (function() {
            if (!(cert.isOriginatingFromAny(['Template']))) {
              return false;
            }
            return true;
          }()) {
            validationRules.violateWithMessage(cert, violations, 'CannotUtiFromTemplate')
          }
          // rule assertUserHasNotSignedLastOtherSignature not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['IsolationInProgress', 'IsolationInProgressForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: Isolation
      VerifyIsolation: {
        key: 'VerifyIsolation', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireLevel2RiskAssessmentForNonStandardSchemes/>
          validationRules.requireLevel2RiskAssessmentForNonStandardSchemes(cert, violations, ['Mechanical', 'ElectricalLowVoltage', 'ElectricalHighVoltage', 'InhibitsAndOverrides']);
          // Rule <restrictWorkItemAttachment/>
          if (function() {
            if (!(_.some(cert.attachments, function(att) { return att.kind === 'TaskRiskAssessment' && (function(cert) {
              return true;
            })(att) }))) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictWorkItemAttachment(cert, violations, {
              kind: 'TaskRiskAssessment',
              isRequired: false,
              variants: [],
              inStates: ['Active'],
              notInStates: [],
              anyInStates: []
            });
          }
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['AwaitingVerification', 'AwaitingVerificationForAmendment'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingVerification', 'AwaitingVerificationForAmendment'], cert.state));
          return complies;
        }
      }
    },
    IsolationTemplate: {
      // kind: IsolationTemplate
      ApproveIsolationTemplate: {
        key: 'ApproveIsolationTemplate', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <scheduleNextReview> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['AwaitingApproval'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingApproval'], cert.state));
          return complies;
        }
      },
      // kind: IsolationTemplate
      AuthoriseIsolationTemplate: {
        key: 'AuthoriseIsolationTemplate', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['AwaitingVerification'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingVerification'], cert.state));
          return complies;
        }
      },
      // kind: IsolationTemplate
      CloseIsolationTemplate: {
        key: 'CloseIsolationTemplate', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'PermitTemplate',
            prohibitedStates: ['Active', 'InReview'],
            allowedStates: []
          });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Active', 'InReview'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'InReview'], cert.state));
          return complies;
        }
      },
      // kind: IsolationTemplate
      ProposeElectricalHighVoltageIsolationTemplateScheme: {
        key: 'ProposeElectricalHighVoltageIsolationTemplateScheme', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // rule requireIsolationMethodsToBeAvailable not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalHighVoltage']))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: IsolationTemplate
      ProposeElectricalLowVoltageIsolationTemplateScheme: {
        key: 'ProposeElectricalLowVoltageIsolationTemplateScheme', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // rule requireIsolationMethodsToBeAvailable not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasIsolationTypes(cert, ['ElectricalLowVoltage']))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: IsolationTemplate
      ProposeInhibitsAndOverridesIsolationTemplateScheme: {
        key: 'ProposeInhibitsAndOverridesIsolationTemplateScheme', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <requireIsolation/>
          if (function() {
            // unsupportedCondition hasIsolationsThatAreUnableToIsolate
            return true;
          }()) {
            validationRules.requireIsolation(cert, violations, 'InhibitsAndOverrides')
          }
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // rule requireIsolationMethodsToBeAvailable not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasIsolationTypes(cert, ['InhibitsAndOverrides']))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: IsolationTemplate
      ProposeMechanicalIsolationTemplateScheme: {
        key: 'ProposeMechanicalIsolationTemplateScheme', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <requireIsolation/>
          if (function() {
            // unsupportedCondition hasIsolationsThatAreUnableToIsolate
            return true;
          }()) {
            validationRules.requireIsolation(cert, violations, 'Mechanical')
          }
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(certificateMethods.hasIsolationTypes(cert, ['Mechanical']))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: IsolationTemplate
      ReviewIsolationTemplate: {
        key: 'ReviewIsolationTemplate', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <scheduleNextReview> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['InReview', 'Active'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['InReview', 'Active'], cert.state));
          return complies;
        }
      }
    },
    ManualBarrierOverride: {
      // kind: ManualBarrierOverride
      ApproveManualBarrierOverride: {
        key: 'ApproveManualBarrierOverride', numberOfSignatures: 'Single', isResignable: false, periodType: 'Initial', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"period","readonly":false},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          // rule publishToBarrierVision not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['AwaitingApproval'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingApproval'], cert.state));
          return complies;
        }
      },
      // kind: ManualBarrierOverride
      CloseManualBarrierOverride: {
        key: 'CloseManualBarrierOverride', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule publishToBarrierVision not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Active', 'Revalidate'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'Revalidate'], cert.state));
          return complies;
        }
      },
      // kind: ManualBarrierOverride
      Counter: {
        key: 'Counter', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: ManualBarrierOverride
      ReapproveManualBarrierOverride: {
        key: 'ReapproveManualBarrierOverride', numberOfSignatures: 'Single', isResignable: false, periodType: 'Revalidation', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"period","readonly":false},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <approvePeriod> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Active', 'Revalidate'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'Revalidate'], cert.state));
          return complies;
        }
      },
      // kind: ManualBarrierOverride
      RequestManualBarrierOverride: {
        key: 'RequestManualBarrierOverride', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requirePlannedWorkingPeriod/>
          validationRules.requirePlannedWorkingPeriod(cert, violations);
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requireProperties/>
          validationRules.requireProperty(cert, violations, { key: 'SafeguardCategoryField', values: [] });
          validationRules.requireProperty(cert, violations, { key: 'OverrideSafeguardStatusField', values: [] });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Requesting'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      }
    },
    ManualDataEntry: {
      // kind: ManualDataEntry
      ApproveManualDataEntry: {
        key: 'ApproveManualDataEntry', numberOfSignatures: 'Single', isResignable: false, periodType: 'Initial', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"period","readonly":false},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.DateRangeRequired))) {
            return false;
          }
          if (!(_.includes(['AwaitingApproval'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingApproval'], cert.state));
          return complies;
        }
      },
      // kind: ManualDataEntry
      CloseManualDataEntryWithoutValidity: {
        key: 'CloseManualDataEntryWithoutValidity', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.textProperties && _.includes(['No'], cert.textProperties.DateRangeRequired))) {
            return false;
          }
          if (!(_.includes(['AwaitingApproval'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingApproval'], cert.state));
          return complies;
        }
      },
      // kind: ManualDataEntry
      CloseManualDataEntryWithValidity: {
        key: 'CloseManualDataEntryWithValidity', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.DateRangeRequired))) {
            return false;
          }
          if (!(_.includes(['Closing'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Closing'], cert.state));
          return complies;
        }
      },
      // kind: ManualDataEntry
      ClosingManualDataEntry: {
        key: 'ClosingManualDataEntry', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.DateRangeRequired))) {
            return false;
          }
          if (!(_.includes(['Active', 'Revalidate'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'Revalidate'], cert.state));
          return complies;
        }
      },
      // kind: ManualDataEntry
      Counter: {
        key: 'Counter', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: ManualDataEntry
      ReapproveManualDataEntry: {
        key: 'ReapproveManualDataEntry', numberOfSignatures: 'Single', isResignable: false, periodType: 'Revalidation', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"period","readonly":false},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <approvePeriod> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Active', 'Revalidate'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'Revalidate'], cert.state));
          return complies;
        }
      },
      // kind: ManualDataEntry
      RequestManualDataEntry: {
        key: 'RequestManualDataEntry', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireProperties/>
          validationRules.requireProperty(cert, violations, { key: 'MetricTypeField', values: [] });
          validationRules.requireProperty(cert, violations, { key: 'ValueTextField', values: [] });
          // Rule <requirePlannedWorkingPeriod/>
          if (function() {
            if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.DateRangeRequired))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requirePlannedWorkingPeriod(cert, violations);
          }
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Requesting'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      }
    },
    NonPermittedWork: {
      // kind: NonPermittedWork
      ApproveNPW: {
        key: 'ApproveNPW', numberOfSignatures: 'Single', isResignable: false, periodType: 'Initial', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"period","readonly":false},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireNumberOfPersons/>
          validationRules.requireNumberOfPersons(cert, violations);
          // Rule <requirePlannedWorkingPeriod/>
          validationRules.requirePlannedWorkingPeriod(cert, violations);
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <requireProperties/>
          validationRules.requireProperty(cert, violations, { key: 'RiskAssessmentRequired', values: [] });
          // Rule <requireRiskAssessmentComplete/>
          if (function() {
            if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.RiskAssessmentRequired))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentComplete(cert, violations);
          }
          // Rule <requireRiskAssessmentLevel/>
          validationRules.requireRiskAssessmentLevel(cert, violations, '');
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'WorkPack',
            prohibitedStates: [],
            allowedStates: ['Active']
          });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((_.includes(['Requesting'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingApproval'], cert.state));
          return complies;
        }
      },
      // kind: NonPermittedWork
      CloseNPW: {
        key: 'CloseNPW', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          // rule closeValidPeriods not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Active', 'Expired', 'Revalidate', 'AwaitingActivation'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'Expired', 'Revalidate', 'AwaitingActivation'], cert.state));
          return complies;
        }
      },
      // kind: NonPermittedWork
      Counter: {
        key: 'Counter', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting', 'AwaitingApproval', 'AwaitingActivation', 'Active', 'Revalidate', 'Expired'], cert.state));
          return complies;
        }
      },
      // kind: NonPermittedWork
      MarkAsNotCopyable: {
        key: 'MarkAsNotCopyable', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <markAsNotCopyable> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((cert.signedWith(['MarkAsNotCopyable'], []))) {
            return false;
          }
          if ((_.includes(['Requesting'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingApproval', 'AwaitingActivation', 'Revalidate', 'Expired', 'Active', 'Closed'], cert.state));
          return complies;
        }
      },
      // kind: NonPermittedWork
      RequestNPW: {
        key: 'RequestNPW', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireNumberOfPersons/>
          validationRules.requireNumberOfPersons(cert, violations);
          // Rule <requirePlannedWorkingPeriod/>
          validationRules.requirePlannedWorkingPeriod(cert, violations);
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <requireProperties/>
          validationRules.requireProperty(cert, violations, { key: 'RiskAssessmentRequired', values: [] });
          // Rule <requireRiskAssessmentComplete/>
          if (function() {
            if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.RiskAssessmentRequired))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentComplete(cert, violations);
          }
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      }
    },
    Permit: {
      // kind: Permit
      AcceptPermit: {
        key: 'AcceptPermit', numberOfSignatures: 'Single', isResignable: false, periodType: 'Initial', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"period","readonly":true},{"name":"remarks","isRequired":false},{"name":"guestSignature"},{"name":"wetInkSignature"}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireSignature/>
          validationRules.requireSignature(cert, violations, {
            signatures: ['IssuePermit'],
            requiredSignersProperty: '',
            proceedWhenNoSignersAvailable: false
          });
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Issued'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      AuthorisePermit: {
        key: 'AuthorisePermit', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkItemAttachment/>
          if (function() {
            if (!(_.includes(['Full'], cert.isolationCertificateRequirement))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              variants: [],
              inStates: [],
              notInStates: []
            });
          }
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingAuthorisation'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      ClosePermitByPermitHolder: {
        key: 'ClosePermitByPermitHolder', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"workStatus","uniqueKey":"workStatus_0"},{"name":"remarks","isRequired":false},{"name":"guestSignature"},{"name":"wetInkSignature"}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireWorkItemAttachment/>
          if (function() {
            if (!(_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && (function(cert) {
              return true;
            })(att) }))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              variants: [],
              inStates: [],
              notInStates: ['RequestedForSanctionToTest']
            });
          }
          // rule closeValidPeriods not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingActivation', 'AwaitingActivationForSanctionToTest', 'ActiveForSanctionToTest', 'Revalidate', 'SuspensionInProgress', 'SuspendedForRevalidation', 'SuspendedForEmergency', 'Active', 'Expired', 'ReIssued', 'ReIssuedForSanctionToTest', 'SuspendedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      ClosePermitByPermitIssuer: {
        key: 'ClosePermitByPermitIssuer', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Closing'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      Counter: {
        key: 'Counter', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: Permit
      GasTesting: {
        key: 'GasTesting', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"addMeasurements","detectorNumberUsage":"Optional","canAddMeasurementsForAdditionalSubstances":"true","uniqueKey":"addMeasurements_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((_.includes(['Closed'], cert.state))) {
            return false;
          }
          if (!(cert.measurementRequirements && cert.measurementRequirements.requiredMeasurements
          && cert.measurementRequirements.requiredMeasurements.length > 0)) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: Permit
      IssuePermit: {
        key: 'IssuePermit', numberOfSignatures: 'Single', isResignable: false, periodType: 'Initial', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"existingMeasurements","uniqueKey":"existingMeasurements_0"},{"name":"selfDeclaration","errorResource":"SelfDeclaration_ErrorMessagePermit","textResource":"SelfDeclaration_IssuePermit","uniqueKey":"selfDeclaration_1"},{"name":"confirmPrerequisiteControlsInPlace","errorResource":"SelfDeclaration_ErrorMessagePermit","textResource":"SelfDeclaration_PrequisiteControlsInPlaceIssuePermit","uniqueKey":"confirmPrerequisiteControlsInPlace_2"},{"name":"period","readonly":false},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictWorkItemAttachment/>
          if (function() {
            if (!(/* <anyOf> condition: a single condition below must match */
            function() {
              if ((_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && (function(cert) {
                return true;
              })(att) }))) {
                return true;
              }
              if ((_.includes(['Full'], cert.isolationCertificateRequirement))) {
                return true;
              }
              return false; /* Not any condition is true, so return false */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              isRequired: true,
              variants: [],
              inStates: ['IsolationInPlace'],
              notInStates: [],
              anyInStates: []
            });
          }
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'WorkPack',
            prohibitedStates: [],
            allowedStates: ['Active']
          });
          // Rule <transition> is explicitly excluded from client side code generation
          // rule requireMeasurementsAfterSignature not yet implemented
          // Rule <assertPermitDependenciesAreSatisfied> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingIssue'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      MarkAsNotCopyable: {
        key: 'MarkAsNotCopyable', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <markAsNotCopyable> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((cert.signedWith(['MarkAsNotCopyable'], []))) {
            return false;
          }
          if ((_.includes(['Requesting', 'DraftShutdown'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: Permit
      ReacceptPermit: {
        key: 'ReacceptPermit', numberOfSignatures: 'Single', isResignable: false, periodType: 'Revalidation', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"period","readonly":true},{"name":"remarks","isRequired":false},{"name":"guestSignature"},{"name":"wetInkSignature"}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireSignature/>
          validationRules.requireSignature(cert, violations, {
            signatures: ['ReissuePermit'],
            requiredSignersProperty: '',
            proceedWhenNoSignersAvailable: false
          });
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['ReIssued'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['ReIssued'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      ReAcceptPermitForSanctionToTest: {
        key: 'ReAcceptPermitForSanctionToTest', numberOfSignatures: 'Single', isResignable: false, periodType: 'Revalidation', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"period","readonly":true},{"name":"remarks","isRequired":false},{"name":"guestSignature"},{"name":"wetInkSignature"}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireSignature/>
          validationRules.requireSignature(cert, violations, {
            signatures: ['ReIssuePermitForSanctionToTest'],
            requiredSignersProperty: '',
            proceedWhenNoSignersAvailable: false
          });
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['ReIssuedForSanctionToTest'], cert.state))) {
            return false;
          }
          if (!(_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && (function(cert) {
            return true;
          })(att) }))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['ReIssuedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      ReissuePermit: {
        key: 'ReissuePermit', numberOfSignatures: 'Single', isResignable: false, periodType: 'Revalidation', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"existingMeasurements","uniqueKey":"existingMeasurements_0"},{"name":"selfDeclaration","textResource":"SelfDeclaration_IssuePermit","errorResource":"SelfDeclaration_ErrorMessagePermit","uniqueKey":"selfDeclaration_1"},{"name":"confirmPrerequisiteControlsInPlace","textResource":"SelfDeclaration_PrequisiteControlsInPlaceIssuePermit","errorResource":"SelfDeclaration_ErrorMessagePermit","uniqueKey":"confirmPrerequisiteControlsInPlace_2"},{"name":"period","readonly":false},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictWorkItemAttachment/>
          if (function() {
            if (!(/* <anyOf> condition: a single condition below must match */
            function() {
              if ((_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && (function(cert) {
                return true;
              })(att) }))) {
                return true;
              }
              if ((_.includes(['Full'], cert.isolationCertificateRequirement))) {
                return true;
              }
              return false; /* Not any condition is true, so return false */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              isRequired: true,
              variants: [],
              inStates: ['IsolationInPlace'],
              notInStates: [],
              anyInStates: []
            });
          }
          // rule requireMeasurementsAfterSignature not yet implemented
          // Rule <assertPermitDependenciesAreSatisfied> is explicitly excluded from client side code generation
          // Rule <restrictParentState/>
          validationRules.restrictParentState(cert, violations, {
            kind: 'WorkPack',
            prohibitedStates: [],
            allowedStates: ['Active']
          });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['SuspendedForEmergency', 'SuspendedForRevalidation'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['SuspendedForEmergency', 'SuspendedForRevalidation'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      ReIssuePermitForSanctionToTest: {
        key: 'ReIssuePermitForSanctionToTest', numberOfSignatures: 'Single', isResignable: false, periodType: 'Revalidation', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"existingMeasurements","uniqueKey":"existingMeasurements_0"},{"name":"selfDeclaration","errorResource":"SelfDeclaration_ErrorMessagePermit","textResource":"SelfDeclaration_IssuePermit","uniqueKey":"selfDeclaration_1"},{"name":"confirmPrerequisiteControlsInPlace","errorResource":"SelfDeclaration_ErrorMessagePermit","textResource":"SelfDeclaration_PrequisiteControlsInPlaceIssuePermit","uniqueKey":"confirmPrerequisiteControlsInPlace_2"},{"name":"period","readonly":false},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictWorkItemAttachment/>
          if (function() {
            if (!(/* <anyOf> condition: a single condition below must match */
            function() {
              if ((_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && (function(cert) {
                return true;
              })(att) }))) {
                return true;
              }
              if ((_.includes(['Full'], cert.isolationCertificateRequirement))) {
                return true;
              }
              return false; /* Not any condition is true, so return false */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              isRequired: false,
              variants: [],
              inStates: [],
              notInStates: [],
              anyInStates: ['IsolationInPlaceForSanctionToTest']
            });
          }
          // Rule <restrictWorkItemAttachment/>
          if (function() {
            if (!(_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && (function(cert) {
              return true;
            })(att) }))) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              isRequired: false,
              variants: [],
              inStates: [],
              notInStates: ['RequestedForSanctionToTest', 'RequestedForAmendment', 'AwaitingVerificationForAmendment', 'AwaitingAuthorisationForAmendment', 'IsolationInProgressForAmendment'],
              anyInStates: []
            });
          }
          // Rule <transition> is explicitly excluded from client side code generation
          // rule requireMeasurementsAfterSignature not yet implemented
          // Rule <assertPermitDependenciesAreSatisfied> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['SuspendedForEmergency', 'SuspendedForSanctionToTest'], cert.state))) {
            return false;
          }
          if (!(_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && (function(cert) {
            return true;
          })(att) }))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['SuspendedForEmergency', 'SuspendedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      RequestDraftShutdownPermit: {
        key: 'RequestDraftShutdownPermit', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <requireDiscipline/>
          validationRules.requireDiscipline(cert, violations);
          // Rule <requireNumberOfPersons/>
          validationRules.requireNumberOfPersons(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requirePlannedWorkingPeriod/>
          validationRules.requirePlannedWorkingPeriod(cert, violations);
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <requireWorkItemAttachment/>
          if (function() {
            if (!(_.includes(['Full'], cert.isolationCertificateRequirement))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              variants: [],
              inStates: [],
              notInStates: []
            });
          }
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <requireRequiredMeasurements/>
          if (function() {
            if (!(_.includes(['ConfinedSpaceEntry'], cert.variant))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRequiredMeasurements(cert, violations, {
              substanceCodes: []
            })
          }
          // Rule <requireRiskAssessmentComplete/>
          validationRules.requireRiskAssessmentComplete(cert, violations);
          // Rule <requireRiskAssessmentLevel/>
          validationRules.requireRiskAssessmentLevel(cert, violations, '');
          // Rule <requireRiskAssessmentTeam/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentTeam(cert, violations, {
              minimumNumberOfTeamMembers: 2,
              ignoreContractedTeamMembers: true
            });
          }
          // Rule <requireRiskRatingComplete/>
          validationRules.requireRiskRatingComplete(cert, violations);
          // Rule <requireSignature/>
          if (function() {
            if ((cert.isOriginatingFromAny(['Template']))) {
              return false;
            }
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSignature(cert, violations, {
              signatures: ['RequestPermitTRAByTeamMember'],
              requiredSignersProperty: 'Approvingteammembers',
              proceedWhenNoSignersAvailable: false
            });
          }
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['DraftShutdown'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['DraftShutdown'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      RequestPermit: {
        key: 'RequestPermit', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireDiscipline/>
          validationRules.requireDiscipline(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <requireNumberOfPersons/>
          validationRules.requireNumberOfPersons(cert, violations);
          // Rule <requirePlannedWorkingPeriod/>
          validationRules.requirePlannedWorkingPeriod(cert, violations);
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <requireWorkItemAttachment/>
          if (function() {
            if (!(_.includes(['Full'], cert.isolationCertificateRequirement))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              variants: [],
              inStates: [],
              notInStates: []
            });
          }
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <requireRequiredMeasurements/>
          if (function() {
            if (!(_.includes(['ConfinedSpaceEntry'], cert.variant))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRequiredMeasurements(cert, violations, {
              substanceCodes: []
            })
          }
          // Rule <requireRiskAssessmentComplete/>
          validationRules.requireRiskAssessmentComplete(cert, violations);
          // Rule <requireRiskAssessmentLevel/>
          validationRules.requireRiskAssessmentLevel(cert, violations, '');
          // Rule <requireRiskAssessmentTeam/>
          if (function() {
            if ((cert.isOriginatingFromAny(['Template']))) {
              return false;
            }
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentTeam(cert, violations, {
              minimumNumberOfTeamMembers: 2,
              ignoreContractedTeamMembers: true
            });
          }
          // Rule <requireRiskRatingComplete/>
          validationRules.requireRiskRatingComplete(cert, violations);
          // Rule <requireSignature/>
          if (function() {
            if ((cert.isOriginatingFromAny(['Template']))) {
              return false;
            }
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSignature(cert, violations, {
              signatures: ['RequestPermitTRAByTeamMember'],
              requiredSignersProperty: 'Approvingteammembers',
              proceedWhenNoSignersAvailable: false
            });
          }
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Requesting'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      RequestPermitTRAByTeamMember: {
        key: 'RequestPermitTRAByTeamMember', numberOfSignatures: 'SinglePerUser', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function(cert) {
          return _.uniqBy(_.flatten([cert.findAuthorities('ApprovingTeamMembers')].concat([])), 'id');
        },
        getRoles: function(cert) {
          return _.uniq(_.flatten([cert.roleAuthorities['ApprovingTeamMembers'] || []]));
        },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireRiskRatingComplete/>
          validationRules.requireRiskRatingComplete(cert, violations);
          // Rule <requireRiskAssessmentComplete/>
          validationRules.requireRiskAssessmentComplete(cert, violations);
          // Rule <requireRiskAssessmentTeam/>
          validationRules.requireRiskAssessmentTeam(cert, violations, {
            minimumNumberOfTeamMembers: 2,
            ignoreContractedTeamMembers: true
          });
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((cert.isOriginatingFromAny(['Template']))) {
            return false;
          }
          if (!(cert.riskAssessmentLevel === 'Level2')) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting', 'DraftShutdown'], cert.state) && ((cert.findAuthorities('ApprovingTeamMembers').length > 0) || (cert.roleAuthorities['ApprovingTeamMembers'] && cert.roleAuthorities['ApprovingTeamMembers'].length > 0)));
          return complies;
        }
      },
      // kind: Permit
      SuspendPermitByPermitHolder: {
        key: 'SuspendPermitByPermitHolder', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingActivation', 'Active', 'AwaitingActivationForSanctionToTest', 'ActiveForSanctionToTest', 'Revalidate'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      SuspendPermitForEmergency: {
        key: 'SuspendPermitForEmergency', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Active', 'AwaitingActivation', 'ActiveForSanctionToTest', 'AwaitingActivationForSanctionToTest', 'Revalidate', 'SuspensionInProgress'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'AwaitingActivation', 'ActiveForSanctionToTest', 'AwaitingActivationForSanctionToTest', 'Revalidate', 'SuspensionInProgress'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      SuspendPermitForRevalidation: {
        key: 'SuspendPermitForRevalidation', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['SuspensionInProgress', 'SuspendedForEmergency', 'SuspendedForSanctionToTest'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['SuspensionInProgress', 'SuspendedForEmergency', 'SuspendedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      SuspendPermitForSanctionToTest: {
        key: 'SuspendPermitForSanctionToTest', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'Isolation',
            isRequired: false,
            variants: [],
            inStates: [],
            notInStates: [],
            anyInStates: ['IsolationInPlace', 'IsolationInPlaceForSanctionToTest']
          });
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['SuspensionInProgress', 'SuspendedForEmergency', 'SuspendedForRevalidation'], cert.state))) {
            return false;
          }
          if (!(_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && _.includes(['IsolationInPlace', 'IsolationInPlaceForSanctionToTest'], att.state) && (function(cert) {
            return true;
          })(att) }))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['SuspensionInProgress', 'SuspendedForEmergency', 'SuspendedForRevalidation'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      TakeOverPermitHolder: {
        key: 'TakeOverPermitHolder', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false},{"name":"guestSignature"},{"name":"wetInkSignature"}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          // rule assignAuthority not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingActivation', 'Active', 'ActiveForSanctionToTest', 'AwaitingActivationForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      TakeOverPermitIssuer: {
        key: 'TakeOverPermitIssuer', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false},{"name":"guestSignature"},{"name":"wetInkSignature"}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          // rule assignAuthority not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Issued', 'AwaitingActivation', 'Active', 'ActiveForSanctionToTest', 'AwaitingActivationForSanctionToTest', 'ReIssued', 'ReIssuedForSanctionToTest'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      VerifyPermit: {
        key: 'VerifyPermit', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <assertUserHasNotSignedOtherSignatures> is explicitly excluded from client side code generation
          // Rule <requireWorkItemAttachment/>
          if (function() {
            if (!(_.includes(['Full'], cert.isolationCertificateRequirement))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              variants: [],
              inStates: [],
              notInStates: []
            });
          }
          // Rule <requireRequiredMeasurements/>
          if (function() {
            if (!(_.includes(['ConfinedSpaceEntry'], cert.variant))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRequiredMeasurements(cert, violations, {
              substanceCodes: []
            })
          }
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['AwaitingVerification'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingVerification'], cert.state));
          return complies;
        }
      },
      // kind: Permit
      WorkPartyAcknowledgement: {
        key: 'WorkPartyAcknowledgement', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false},{"name":"guestSignature"},{"name":"wetInkSignature"}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingActivation', 'Active', 'AwaitingActivationForSanctionToTest', 'ActiveForSanctionToTest'], cert.state));
          return complies;
        }
      }
    },
    PermitTemplate: {
      // kind: PermitTemplate
      ApprovePermitTemplate: {
        key: 'ApprovePermitTemplate', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'IsolationTemplate',
            isRequired: false,
            variants: [],
            inStates: ['Active'],
            notInStates: [],
            anyInStates: []
          });
          // Rule <scheduleNextReview> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingApproval'], cert.state));
          return complies;
        }
      },
      // kind: PermitTemplate
      ClosePermitTemplate: {
        key: 'ClosePermitTemplate', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'InReview'], cert.state));
          return complies;
        }
      },
      // kind: PermitTemplate
      ReapprovePermitTemplate: {
        key: 'ReapprovePermitTemplate', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <scheduleNextReview> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'InReview'], cert.state));
          return complies;
        }
      },
      // kind: PermitTemplate
      RequestPermitTemplate: {
        key: 'RequestPermitTemplate', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <requireDiscipline/>
          validationRules.requireDiscipline(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <restrictWorkItemAttachment/>
          if (function() {
            if (!(_.includes(['Full'], cert.isolationCertificateRequirement))) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictWorkItemAttachment(cert, violations, {
              kind: 'IsolationTemplate',
              isRequired: true,
              variants: [],
              inStates: [],
              notInStates: [],
              anyInStates: []
            });
          }
          // Rule <requireRequiredMeasurements/>
          if (function() {
            if (!(_.includes(['ConfinedSpaceEntry'], cert.variant))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRequiredMeasurements(cert, violations, {
              substanceCodes: []
            })
          }
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <requireRiskAssessmentComplete/>
          validationRules.requireRiskAssessmentComplete(cert, violations);
          // Rule <requireRiskAssessmentLevel/>
          validationRules.requireRiskAssessmentLevel(cert, violations, '');
          // Rule <requireRiskAssessmentTeam/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentTeam(cert, violations, {
              minimumNumberOfTeamMembers: 2,
              ignoreContractedTeamMembers: true
            });
          }
          // Rule <requireRiskRatingComplete/>
          validationRules.requireRiskRatingComplete(cert, violations);
          // Rule <requireSignature/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSignature(cert, violations, {
              signatures: ['RequestPermitTRATemplateByTeamMember'],
              requiredSignersProperty: 'Approvingteammembers',
              proceedWhenNoSignersAvailable: false
            });
          }
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: PermitTemplate
      RequestPermitTRATemplateByTeamMember: {
        key: 'RequestPermitTRATemplateByTeamMember', numberOfSignatures: 'SinglePerUser', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function(cert) {
          return _.uniqBy(_.flatten([cert.findAuthorities('ApprovingTeamMembers')].concat([])), 'id');
        },
        getRoles: function(cert) {
          return _.uniq(_.flatten([cert.roleAuthorities['ApprovingTeamMembers'] || []]));
        },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireRiskRatingComplete/>
          validationRules.requireRiskRatingComplete(cert, violations);
          // Rule <requireRiskAssessmentComplete/>
          validationRules.requireRiskAssessmentComplete(cert, violations);
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.riskAssessmentLevel === 'Level2')) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state) && ((cert.findAuthorities('ApprovingTeamMembers').length > 0) || (cert.roleAuthorities['ApprovingTeamMembers'] && cert.roleAuthorities['ApprovingTeamMembers'].length > 0)));
          return complies;
        }
      },
      // kind: PermitTemplate
      VerifyPermitTemplate: {
        key: 'VerifyPermitTemplate', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireRequiredMeasurements/>
          if (function() {
            if (!(_.includes(['ConfinedSpaceEntry'], cert.variant))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRequiredMeasurements(cert, violations, {
              substanceCodes: []
            })
          }
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <restrictWorkItemAttachment/>
          if (function() {
            if (!(_.includes(['Full'], cert.isolationCertificateRequirement))) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictWorkItemAttachment(cert, violations, {
              kind: 'IsolationTemplate',
              isRequired: true,
              variants: [],
              inStates: ['Active'],
              notInStates: [],
              anyInStates: []
            });
          }
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingVerification'], cert.state));
          return complies;
        }
      }
    },
    RiskRecord: {
      // kind: RiskRecord
      ApproveRiskRecord: {
        key: 'ApproveRiskRecord', numberOfSignatures: 'Single', isResignable: false, periodType: 'Initial', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"period","readonly":false},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule publishToBarrierVision not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['AwaitingApproval'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingApproval'], cert.state));
          return complies;
        }
      },
      // kind: RiskRecord
      ClosedRiskRecord: {
        key: 'ClosedRiskRecord', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          // rule publishToBarrierVision not yet implemented
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Closing'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Closing'], cert.state));
          return complies;
        }
      },
      // kind: RiskRecord
      ClosingRiskRecord: {
        key: 'ClosingRiskRecord', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Active', 'Revalidate'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'Revalidate'], cert.state));
          return complies;
        }
      },
      // kind: RiskRecord
      Counter: {
        key: 'Counter', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: RiskRecord
      ReApproveRiskRecord: {
        key: 'ReApproveRiskRecord', numberOfSignatures: 'Single', isResignable: false, periodType: 'Revalidation', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"period","readonly":false},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <approvePeriod> is explicitly excluded from client side code generation
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Active', 'Revalidate'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active', 'Revalidate'], cert.state));
          return complies;
        }
      },
      // kind: RiskRecord
      RequestRiskRecord: {
        key: 'RequestRiskRecord', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <requirePlannedWorkingPeriod/>
          validationRules.requirePlannedWorkingPeriod(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requireProperties/>
          validationRules.requireProperty(cert, violations, { key: 'SafeguardSubCategoryField', values: [] });
          validationRules.requireProperty(cert, violations, { key: 'CurrentSafeguardStatusField', values: [] });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Requesting'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      }
    },
    Task: {
      // kind: Task
      ApproveTask: {
        key: 'ApproveTask', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireDueAt/>
          validationRules.requireDueAt(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireOwner/>
          validationRules.requireOwner(cert, violations);
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: Task
      VerifyTask: {
        key: 'VerifyTask', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"selfDeclaration","textResource":"SelfDeclaration_VerifyTaskCompletedByHSEDepartment","uniqueKey":"selfDeclaration_0"},{"name":"remarks","isRequired":false}],
        getUsers: function(cert) {
          return _.uniqBy(_.flatten([cert.findAuthorities('Owner')].concat([])), 'id');
        },
        getRoles: function(cert) {
          return _.uniq(_.flatten([cert.roleAuthorities['Owner'] || []]));
        },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Open'], cert.state) && ((cert.findAuthorities('Owner').length > 0) || (cert.roleAuthorities['Owner'] && cert.roleAuthorities['Owner'].length > 0)));
          return complies;
        }
      },
      // kind: Task
      VerifyTaskCompletion: {
        key: 'VerifyTaskCompletion', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Verify'], cert.state));
          return complies;
        }
      }
    },
    TaskRiskAssessment: {
      // kind: TaskRiskAssessment
      AcceptTaskRiskAssessment: {
        key: 'AcceptTaskRiskAssessment', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function(cert) {
          return _.uniqBy(_.flatten([cert.findAuthorities('ApproverForJHA')].concat([])), 'id');
        },
        getRoles: function(cert) {
          return _.uniq(_.flatten([cert.roleAuthorities['ApproverForJHA'] || []]));
        },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireSignature/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSignature(cert, violations, {
              signatures: ['RequestTaskRiskAssessmentByTeamMember'],
              requiredSignersProperty: 'Approvingteammembers',
              proceedWhenNoSignersAvailable: true
            });
          }
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.riskAssessmentLevel === 'Level2')) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingApproval'], cert.state) && ((cert.findAuthorities('ApproverForJHA').length > 0) || (cert.roleAuthorities['ApproverForJHA'] && cert.roleAuthorities['ApproverForJHA'].length > 0)));
          return complies;
        }
      },
      // kind: TaskRiskAssessment
      CloseTaskRiskAssessment: {
        key: 'CloseTaskRiskAssessment', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active'], cert.state));
          return complies;
        }
      },
      // kind: TaskRiskAssessment
      RequestTaskRiskAssessmentByTeamMember: {
        key: 'RequestTaskRiskAssessmentByTeamMember', numberOfSignatures: 'SinglePerUser', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function(cert) {
          return _.uniqBy(_.flatten([cert.findAuthorities('ApprovingTeamMembers')].concat([])), 'id');
        },
        getRoles: function(cert) {
          return _.uniq(_.flatten([cert.roleAuthorities['ApprovingTeamMembers'] || []]));
        },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireRiskRatingComplete/>
          validationRules.requireRiskRatingComplete(cert, violations);
          // Rule <requireRiskAssessmentComplete/>
          validationRules.requireRiskAssessmentComplete(cert, violations);
          // Rule <requireSystemOrEquipment/>
          validationRules.requireSystemOrEquipment(cert, violations);
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // rule restrictAuthorities not yet implemented
          // Rule <requireRiskAssessmentTeam/>
          validationRules.requireRiskAssessmentTeam(cert, violations, {
            minimumNumberOfTeamMembers: 2,
            ignoreContractedTeamMembers: true
          });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.riskAssessmentLevel === 'Level2')) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state) && ((cert.findAuthorities('ApprovingTeamMembers').length > 0) || (cert.roleAuthorities['ApprovingTeamMembers'] && cert.roleAuthorities['ApprovingTeamMembers'].length > 0)));
          return complies;
        }
      }
    },
    Training: {
      // kind: Training
      CloseTrainingByPermitHolder: {
        key: 'CloseTrainingByPermitHolder', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Closing'], cert.state));
          return complies;
        }
      },
      // kind: Training
      ClosingTrainingByPermitHolder: {
        key: 'ClosingTrainingByPermitHolder', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"workStatus","uniqueKey":"workStatus_0"},{"name":"remarks","isRequired":false},{"name":"wetInkSignature"}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule closeValidPeriods not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active'], cert.state));
          return complies;
        }
      },
      // kind: Training
      ClosingTrainingFromSuspendedForEmergency: {
        key: 'ClosingTrainingFromSuspendedForEmergency', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false},{"name":"wetInkSignature"}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // rule closeValidPeriods not yet implemented
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['SuspendedForEmergency'], cert.state));
          return complies;
        }
      },
      // kind: Training
      Counter: {
        key: 'Counter', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: Training
      FastClose: {
        key: 'FastClose', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <violateWithMessage/>
          if (function() {
            if (!(/* <all> condition: all conditions below must match */
            function() {
              if ((cert.textProperties && cert.textProperties.Comment1)) {
                return false;
              }
              if ((cert.textProperties && cert.textProperties.CriticalComment)) {
                return false;
              }
              return true; /* No condition was false, so return true */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.violateWithMessage(cert, violations, 'CommentCriticalCommentNoValue')
          }
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Requesting'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: Training
      GasTesting: {
        key: 'GasTesting', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((_.includes(['Closed'], cert.state))) {
            return false;
          }
          if (!(cert.measurementRequirements && cert.measurementRequirements.requiredMeasurements
          && cert.measurementRequirements.requiredMeasurements.length > 0)) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: Training
      MarkAsNotCopyable: {
        key: 'MarkAsNotCopyable', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <markAsNotCopyable> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((cert.signedWith(['MarkAsNotCopyable'], []))) {
            return false;
          }
          if ((_.includes(['Requesting'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: Training
      RequestTraining: {
        key: 'RequestTraining', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireProperties/>
          validationRules.requireProperty(cert, violations, { key: 'IsItCritical', values: [] });
          // Rule <requireProperties/>
          if (function() {
            if (!(cert.textProperties && _.includes(['No'], cert.textProperties.IsItCritical))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireProperty(cert, violations, { key: 'Comment1', values: [] });
          }
          // Rule <requireProperties/>
          if (function() {
            if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.IsItCritical))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireProperty(cert, violations, { key: 'CriticalComment', values: [] });
          }
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <restrictWorkItemAttachment/>
          if (function() {
            if (!(/* <anyOf> condition: a single condition below must match */
            function() {
              if ((_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && (function(cert) {
                return true;
              })(att) }))) {
                return true;
              }
              if ((_.includes(['Full'], cert.isolationCertificateRequirement))) {
                return true;
              }
              return false; /* Not any condition is true, so return false */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.restrictWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              isRequired: true,
              variants: [],
              inStates: ['IsolationInPlace'],
              notInStates: [],
              anyInStates: []
            });
          }
          // Rule <requirePlannedWorkingPeriod/>
          validationRules.requirePlannedWorkingPeriod(cert, violations);
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <requireRiskAssessmentComplete/>
          validationRules.requireRiskAssessmentComplete(cert, violations);
          // Rule <requireRiskAssessmentLevel/>
          validationRules.requireRiskAssessmentLevel(cert, violations, '');
          // Rule <requireRiskAssessmentTeam/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentTeam(cert, violations, {
              minimumNumberOfTeamMembers: 2,
              ignoreContractedTeamMembers: true
            });
          }
          // Rule <requireRiskRatingComplete/>
          validationRules.requireRiskRatingComplete(cert, violations);
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Requesting'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: Training
      SuspendTrainingForEmergency: {
        key: 'SuspendTrainingForEmergency', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: false, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(_.includes(['Active'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active'], cert.state));
          return complies;
        }
      }
    },
    WorkItemAudit: {
      // kind: WorkItemAudit
      RequestWorkItemAudit: {
        key: 'RequestWorkItemAudit', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"auditConfirmationMessages","uniqueKey":"auditConfirmationMessages_0"},{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <assertAllQuestionsAnswered/>
          validationRules.assertAllQuestionsAnswered(cert, violations);
          // Rule <requireRemarksForAuditAssessments/>
          validationRules.requireRemarksForAuditAssessments(cert, violations, ['0']);
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: WorkItemAudit
      ReviewWorkItemAudit: {
        key: 'ReviewWorkItemAudit', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingReview'], cert.state));
          return complies;
        }
      }
    },
    WorkPack: {
      // kind: WorkPack
      AcceptWorkPack: {
        key: 'AcceptWorkPack', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'Permit',
            isRequired: false,
            variants: [],
            inStates: [],
            notInStates: ['DraftShutdown', 'Requesting', 'AwaitingVerification', 'AwaitingAuthorisation'],
            anyInStates: []
          });
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'Isolation',
            isRequired: false,
            variants: [],
            inStates: ['IsolationInPlace'],
            notInStates: [],
            anyInStates: []
          });
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'NonPermittedWork',
            isRequired: false,
            variants: [],
            inStates: [],
            notInStates: ['Requesting'],
            anyInStates: []
          });
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['AwaitingActivation', 'AwaitingActivationForAmendment'], cert.state));
          return complies;
        }
      },
      // kind: WorkPack
      AmendWorkPack: {
        key: 'AmendWorkPack', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active'], cert.state));
          return complies;
        }
      },
      // kind: WorkPack
      CloseWorkPack: {
        key: 'CloseWorkPack', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'Isolation',
            isRequired: false,
            variants: [],
            inStates: ['Closed', 'IsolationInPlaceForLongTerm'],
            notInStates: [],
            anyInStates: []
          });
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'Permit',
            isRequired: false,
            variants: [],
            inStates: ['Closed'],
            notInStates: [],
            anyInStates: []
          });
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Closing'], cert.state));
          return complies;
        }
      },
      // kind: WorkPack
      ClosingWorkPack: {
        key: 'ClosingWorkPack', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <transition> is explicitly excluded from client side code generation
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'Permit',
            isRequired: false,
            variants: [],
            inStates: ['Closing', 'Closed'],
            notInStates: [],
            anyInStates: []
          });
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'Isolation',
            isRequired: false,
            variants: [],
            inStates: ['IsolationInPlace', 'IsolationInPlaceForLongTerm'],
            notInStates: [],
            anyInStates: []
          });
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'NonPermittedWork',
            isRequired: false,
            variants: [],
            inStates: ['Closed'],
            notInStates: [],
            anyInStates: []
          });
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Active'], cert.state));
          return complies;
        }
      },
      // kind: WorkPack
      Counter: {
        key: 'Counter', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function() { return true; }
      },
      // kind: WorkPack
      MarkAsCopyable: {
        key: 'MarkAsCopyable', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((cert.canBeCopied)) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForAmendment', 'AwaitingActivation', 'AwaitingActivationForAmendment', 'Active', 'Closing', 'Closed'], cert.state));
          return complies;
        }
      },
      // kind: WorkPack
      MarkAsNotCopyable: {
        key: 'MarkAsNotCopyable', numberOfSignatures: 'Single', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <markAsNotCopyable> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((cert.signedWith(['MarkAsNotCopyable'], []))) {
            return false;
          }
          if ((_.includes(['Requesting'], cert.state))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForAmendment', 'AwaitingActivation', 'AwaitingActivationForAmendment', 'Active', 'Closing', 'Closed'], cert.state));
          return complies;
        }
      },
      // kind: WorkPack
      RequestByRATeamMember: {
        key: 'RequestByRATeamMember', numberOfSignatures: 'SinglePerUser', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function(cert) {
          return _.uniqBy(_.flatten([cert.findAuthorities('ApprovingTeamMembers')].concat([])), 'id');
        },
        getRoles: function(cert) {
          return _.uniq(_.flatten([cert.roleAuthorities['ApprovingTeamMembers'] || []]));
        },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <requireRiskRatingComplete/>
          validationRules.requireRiskRatingComplete(cert, violations);
          // Rule <requireRiskAssessmentComplete/>
          validationRules.requireRiskAssessmentComplete(cert, violations);
          return violations;
        },
        isSignatureVisible: function(cert) {
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting', 'RequestedForAmendment'], cert.state) && ((cert.findAuthorities('ApprovingTeamMembers').length > 0) || (cert.roleAuthorities['ApprovingTeamMembers'] && cert.roleAuthorities['ApprovingTeamMembers'].length > 0)));
          return complies;
        }
      },
      // kind: WorkPack
      RequestWorkPack: {
        key: 'RequestWorkPack', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <violateWithMessage/>
          if (function() {
            if (!(/* <all> condition: all conditions below must match */
            function() {
              if ((_.some(cert.attachments, function(att) { return att.kind === 'Permit' && (function(cert) {
                return true;
              })(att) }))) {
                return false;
              }
              if ((_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && (function(cert) {
                return true;
              })(att) }))) {
                return false;
              }
              if ((_.some(cert.attachments, function(att) { return att.kind === 'NonPermittedWork' && (function(cert) {
                return true;
              })(att) }))) {
                return false;
              }
              return true; /* No condition was false, so return true */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.violateWithMessage(cert, violations, 'WorkPackAttachWorkItemViolation')
          }
          // Rule <markAsCopyable> is explicitly excluded from client side code generation
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requirePlannedWorkingPeriod/>
          validationRules.requirePlannedWorkingPeriod(cert, violations);
          // Rule <requireWorkItemAttachment/>
          if (function() {
            if (!(_.includes(['Full'], cert.isolationCertificateRequirement))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              variants: [],
              inStates: [],
              notInStates: []
            });
          }
          // Rule <requireRiskAssessmentComplete/>
          if (function() {
            if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.IsRAneeded))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentComplete(cert, violations);
          }
          // Rule <requireRiskAssessmentLevel/>
          if (function() {
            if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.IsRAneeded))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentLevel(cert, violations, '');
          }
          // Rule <requireRiskAssessmentTeam/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentTeam(cert, violations, {
              minimumNumberOfTeamMembers: 2,
              ignoreContractedTeamMembers: true
            });
          }
          // Rule <requireRiskRatingComplete/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskRatingComplete(cert, violations);
          }
          // Rule <requireSignature/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSignature(cert, violations, {
              signatures: ['RequestByRATeamMember'],
              requiredSignersProperty: 'Approvingteammembers',
              proceedWhenNoSignersAvailable: false
            });
          }
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if ((cert.signedWith(['AmendWorkPack'], []))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['Requesting'], cert.state));
          return complies;
        }
      },
      // kind: WorkPack
      RequestWorkPackAfterAmendment: {
        key: 'RequestWorkPackAfterAmendment', numberOfSignatures: 'Multiple', isResignable: false, periodType: '', oneClick: true, remarksUsage: 'Optional',
        fields: [{"name":"remarks","isRequired":false}],
        getUsers: function() { return []; },
        getRoles: function() { return []; },
        getRuleViolations: function(cert) {
          var violations = [];
          // Rule <violateWithMessage/>
          if (function() {
            if (!(/* <all> condition: all conditions below must match */
            function() {
              if ((_.some(cert.attachments, function(att) { return att.kind === 'Permit' && (function(cert) {
                return true;
              })(att) }))) {
                return false;
              }
              if ((_.some(cert.attachments, function(att) { return att.kind === 'Isolation' && (function(cert) {
                return true;
              })(att) }))) {
                return false;
              }
              if ((_.some(cert.attachments, function(att) { return att.kind === 'NonPermittedWork' && (function(cert) {
                return true;
              })(att) }))) {
                return false;
              }
              return true; /* No condition was false, so return true */
            }())) {
              return false;
            }
            return true;
          }()) {
            validationRules.violateWithMessage(cert, violations, 'WorkPackAttachWorkItemViolation')
          }
          // Rule <requireWorkDescription/>
          validationRules.requireWorkDescription(cert, violations);
          // Rule <requireWorkLocation/>
          validationRules.requireWorkLocation(cert, violations);
          // Rule <requirePlannedWorkingPeriod/>
          validationRules.requirePlannedWorkingPeriod(cert, violations);
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'Permit',
            isRequired: false,
            variants: [],
            inStates: [],
            notInStates: ['Requesting', 'DraftShutdown', 'AwaitingVerification', 'AwaitingAuthorisation'],
            anyInStates: []
          });
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'Isolation',
            isRequired: false,
            variants: [],
            inStates: [],
            notInStates: ['Requesting', 'AwaitingVerification', 'AwaitingAuthorisation'],
            anyInStates: []
          });
          // Rule <restrictWorkItemAttachment/>
          validationRules.restrictWorkItemAttachment(cert, violations, {
            kind: 'NonPermittedWork',
            isRequired: false,
            variants: [],
            inStates: [],
            notInStates: ['Requesting'],
            anyInStates: []
          });
          // Rule <requireWorkItemAttachment/>
          if (function() {
            if (!(_.includes(['Full'], cert.isolationCertificateRequirement))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireWorkItemAttachment(cert, violations, {
              kind: 'Isolation',
              variants: [],
              inStates: [],
              notInStates: []
            });
          }
          // Rule <requireRiskAssessmentComplete/>
          if (function() {
            if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.IsRAneeded))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentComplete(cert, violations);
          }
          // Rule <requireRiskAssessmentLevel/>
          if (function() {
            if (!(cert.textProperties && _.includes(['Yes'], cert.textProperties.IsRAneeded))) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentLevel(cert, violations, '');
          }
          // Rule <requireRiskAssessmentTeam/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskAssessmentTeam(cert, violations, {
              minimumNumberOfTeamMembers: 2,
              ignoreContractedTeamMembers: true
            });
          }
          // Rule <requireRiskRatingComplete/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireRiskRatingComplete(cert, violations);
          }
          // Rule <requireSignature/>
          if (function() {
            if (!(cert.riskAssessmentLevel === 'Level2')) {
              return false;
            }
            return true;
          }()) {
            validationRules.requireSignature(cert, violations, {
              signatures: ['RequestByRATeamMember'],
              requiredSignersProperty: 'Approvingteammembers',
              proceedWhenNoSignersAvailable: false
            });
          }
          // Rule <transition> is explicitly excluded from client side code generation
          return violations;
        },
        isSignatureVisible: function(cert) {
          if (!(cert.signedWith(['AmendWorkPack'], []))) {
            return false;
          }
          return true;
        },
        isSignatureEnabled: function(cert) {
          var complies = false;
          complies = complies || (_.includes(['RequestedForAmendment'], cert.state));
          return complies;
        }
      }
    }
  };
  return {
    getSignature: function(kind, signatureType) {
      if (!(signaturesPerKind[kind]) || !(signaturesPerKind[kind][signatureType])) {
        log('no configuration found for kind ' + kind + ' and signature: ' + signatureType);
      }
      return signaturesPerKind[kind][signatureType];
    },
    getSignatures: function() {
      return Object.keys(signaturesPerKind[kind]);
    }
  };
})();
